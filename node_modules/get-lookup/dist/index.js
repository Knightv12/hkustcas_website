"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = get;
exports.isLookupKey = isLookupKey;
exports.lookupIndex = lookupIndex;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var lookupTermRegExp;
Object.defineProperty(get, "lookupTermRegExp", {
  enumerable: false,
  configurable: false,
  get: function get() {
    return lookupTermRegExp;
  },
  set: function set(value) {
    var segment = "".concat(value.source, ":").concat(value.source);
    lookupTermRegExp = value;
    this.lookupKeyRegExp = new RegExp("{".concat(segment, "(?:,").concat(segment, ")*}"));
  }
});
get.lookupTermRegExp = /[\w\d_-]+/;

function get(object, path, defaultValue) {
  var result = doGet(object, path);
  return result === undefined ? defaultValue : result;
}

function doGet(object, path) {
  if (!object || !path) return object;

  var _path$match = path.match(/^([^.]+)\.?(.+)?$/),
      _path$match2 = _slicedToArray(_path$match, 3),
      _match = _path$match2[0],
      key = _path$match2[1],
      rest = _path$match2[2];

  if (isLookupKey(key)) {
    if (!Array.isArray(object)) {
      throw new Error("Lookup key '".concat(key, "' cannot be used for non-array object ").concat(JSON.stringify(object)));
    }

    return doGet(object[lookupIndex(object, key)], rest);
  }

  return doGet(object[key], rest);
}

function isLookupKey(key) {
  return get.lookupKeyRegExp.test(key);
}

function lookupIndex(collection, key) {
  var terms = key.substring(1, key.length - 1).split(",").map(function (t) {
    return t.split(":");
  });

  for (var i = 0; i < collection.length; i++) {
    if (collection[i] && matches(collection[i], terms)) {
      return i;
    }
  }

  return -1;
}

function matches(object, terms) {
  for (var i = 0; i < terms.length; i++) {
    if (object[terms[i][0]] != terms[i][1]) {
      return false;
    }
  }

  return true;
}